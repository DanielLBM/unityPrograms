## 常用算法

第一，unity只是一个工具
第二，算法和数据结构和具体的工具无关
第三，编程基本的算法无非是排序算法、树形结构、链表、队列等
第四，算法根据需要去使用，如果是做游戏，一堆的计算机图形学知识需要掌握，如果做3d，必要的3d知识不能少。如果使用物理引擎，请学好各种物理知识。如果做渲染，请做好shader编程的知识储备。
第五，unity提供了足够多的功能，理解是前提，使用是基础，融会贯通是目的 



#### 递归

举例子：阶乘的计算、斐波那契数列

#### 算法一：快速排序

使用分治法(Divide and conquer)策略来把一个串行(list)分为两个子串行(sub-lists)。

　　算法步骤：
  1. 从数列中挑出一个元素，称为 “基准”(pivot)，

  2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区(partition)操作。

　　3. 递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序。
　　递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代(iteration)中，它至少会把一个元素摆到它最后的位置去。

#### 算法二：堆排序算法

　　堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于(或者大于)它的父节点。
　　堆排序的平均时间复杂度为Ο(nlogn) 。
　　算法步骤：
　　1.创建一个堆H[0..n-1]
　　2.把堆首(最大值)和堆尾互换
　　3.把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置
　　4.重复步骤2，直到堆的尺寸为1

　　#### 算法三：归并排序

　　　　归并排序(Merge sort，台湾译作：合并排序)是建立在归并操作上的一种有效的排序算法。该算法是采用分治法(Divide and Conquer)的一个非常典型的应用。
　　　　算法步骤：
　　
  4. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列

  5. 设定两个指针，最初位置分别为两个已经排序序列的起始位置

  6. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置

  7. 重复步骤3直到某一指针达到序列尾

  8. 将另一序列剩下的所有元素直接复制到合并序列尾

       #### 算法四：二分查找算法

       　　二分查找算法是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜 素过程结束;如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组 为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为Ο(logn) 。

       #### 算法五：BFPRT(线性查找算法)

       　　BFPRT算法解决的问题十分经典，即从某n个元素的序列中选出第k大(第k小)的元素，通过巧妙的分 析，BFPRT可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到o(n)的时间复杂 度，五位算法作者做了精妙的处理。
       　　算法步骤：

  9. 将n个元素每5个一组，分成n/5(上界)组。

  10. 取出每一组的中位数，任意排序方法，比如插入排序。

  11. 递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。

  12. 用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。

  13. 若i==k，返回x;若ik，在大于x的元素中递归查找第i-k小的元素。
        终止条件：n=1时，返回的即是i小元素。

        #### 算法六：DFS(深度优先搜索)

        　　深度优先搜索算法(Depth-First-Search)，是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分 支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发 现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。DFS属于盲目搜索。
        　　深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。
        　　深度优先遍历图算法步骤：

  14. 访问顶点v;

  15. 依次从v的未被访问的邻接点出发，对图进行深度优先遍历;直至图中和v有路径相通的顶点都被访问;

  16. 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。
        上述描述可能比较抽象，举个实例：
        　　DFS 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1;再从 w1 出发，访问与 w1邻 接但还没有访问过的顶点 w2;然后再从 w2 出发，进行类似的访问，… 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。
        　　接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问;如果没有，就
      
      ### 冒泡算法
      
      ```c#
      using system;
      
      public class Program
      {
          public viod BubbleSort(int[] arr)
          {
              for(int i = 0;i < arr.Length - 1;i++)
              {
                  for(int j = 0; < arr.Length - i - 1;j++)
                  {
                      if(arr[j+1] > arr[j])
                      {
                          int tmp = arr[j+1];
                          arr[j+1] = arr[j];
                          arr[j] = tmp;
                      }
                  }
              }
          }
          
          public void Swap(int a,int b)
          {
              if(a > b)
              {
                  int tmp = a;
                  a = b;
                  b = tmp;
              }
          }
      }
      ```
      
      



